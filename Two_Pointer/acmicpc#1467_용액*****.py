""" 음수에서 양수까지 임의의 숫자들이 정렬되어 리스트로 주어진다.
그 때, 어떤 두 숫자를 합했을 때 0에 가장 가까운 용액이 되는지, 그 두 숫자를 찾아야한다.


예시를 들어보자.

result = []
distance = 6

주어진 배열 : -10 -6 -4 -2 -1 4 8 11 13 15 16

가장 먼저 -10, 16 으로 6이라는 차이를 만들고 result에 두 숫자 -10, 16을 저장하고, distance 에는 6을 저장한다.


이제 이 배열을 (-10) -9 -6 -4 -2 -1 4 (8 11 13 15 16) 과 같이 볼 것이다.

왼쪾 숫자를 기준으로, 오른쪽 포인터가 가리키는 숫자와의 합이 양/음 부호가 바뀌는 시점까지 체크를 하는 것이다.
     (-10) -9 -6 -4 -2 -1 4 (8 11 13 15 16)
                          음 양  양  양 양
이렇게 되기 때문에, 16~8까지  체크를 해주는 것이다.

-10이라는 숫자와 합해서 양수였던 숫자들은 우리가 추후에 더 볼 필요가 있을까?  절대 없다.
11 + (-10) = 1
11 + (-10보다 큰 수 ( 양수든 음수든) ) = 1보다 더 커짐  ==> 즉, 0보다 더 멀어질 수 밖에 없다는 뜻이다.
추 후에 어떤 일이 있어도 다시 쳐다볼 필요가 없다는 뜻이다.

그러면 이제 남은 배열이 이와 같다 ==> (-10 -9 -6) -4 -2 -1 4 (8)
 8과 -10의 합이 음수이기 때문에, 양수로 바뀌는 시점까지  -10 ~ -6까지를 한 묶음으로 본다.

      (-10 -9 -6) -4 -2 -1 4 (8)
       음   음  양

-10과 -9와 합하며 0과의 거리를 체크하고, distance를 갱신해준다.
추후에 -10, -9를 다시 쳐다봐야할까? 절대 없다.
-10과 8, -9와 8은 결과가 음수이다. 그럼 오른쪽 포인터를 움직여서 0에 더 가까운 값을 찾을 수 있을까 ?
 ==> 우측포인터가 8보다 왼쪽으로 움직인다면, 두 수의 합은 여전히 음수이며, 0과는 더 멀어진다.
 ===> 우측 포인터를 8보다 오른쪽으로 움직인다? 이는 이전 과정에서 이미 접근할 필요가 없다는 것을 증명했었다.
 따라서, 왼쪽 포인터를 -10 => -9 => -6 으로 옮겨, 8과의 합이 음수에서 양수로 바뀐 시점에, distance를 갱신하고,

  (-6) -4 -2 -1 (4 8)

  같은 과정을 반복한다.
   이 배열에서는 -4와 4가 만나면 0 그 자체이므로, 바로 종료하면 된다.
   하지만 -6 -3 -2 -1 4 8 과 같은 상황이라면,
        -6 -3 -2 -1 4
        -3 -2 -1 4
        -3 -2 -1
        -2 -1     이와 같이 최종적으로 두개의 숫자만 남는 상황이 온다. 이때 ,이 두수의 합으로 마지막 갱신을 마치고 결과를 내면된다.

"""

import sys

input = sys.stdin.readline

n = int(input())
data = list(map(int, input().split()))

start = 0
end = len(data) - 1
distance = 2147483647
result_1 = 0
result_2 = 0

while start < end:
    now = data[start] + data[end]
    if now == 0:
        print(data[start], data[end])
        exit()
    absnow = abs(now)
    if absnow < distance:
        result_1, result_2 = data[start], data[end]
        distance = absnow
    if now < 0:
        start += 1
    else:
        end -= 1
print(result_1, result_2)



