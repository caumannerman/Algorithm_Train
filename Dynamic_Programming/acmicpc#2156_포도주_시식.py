"""효주는 포도주 시식회에 갔다. 그 곳에 갔더니, 테이블 위에 다양한 포도주가 들어있는 포도주 잔이 일렬로 놓여 있었다.
효주는 포도주 시식을 하려고 하는데, 여기에는 다음과 같은 두 가지 규칙이 있다.

포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
연속으로 놓여 있는 3잔을 모두 마실 수는 없다.
효주는 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떤 포도주 잔을 선택해야 할지 고민하고 있다.
1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때,
 효주를 도와 가장 많은 양의 포도주를 마실 수 있도록 하는 프로그램을 작성하시오.

예를 들어 6개의 포도주 잔이 있고, 각각의 잔에 순서대로 6, 10, 13, 9, 8, 1 만큼의 포도주가 들어 있을 때,
첫 번째, 두 번째, 네 번째, 다섯 번째 포도주 잔을 선택하면 총 포도주 양이 33으로 최대로 마실 수 있다."""
# 입력 : 첫째 줄에 포도주 잔의 개수 n이 주어진다. (1≤n≤10,000) 둘째 줄부터 n+1번째 줄까지 포도주 잔에 들어있는 포도주의 양이 순서대로 주어진다.
# 포도주의 양은 1,000 이하의 음이 아닌 정수이다.
# 출력 : 첫째 줄에 최대로 마실 수 있는 포도주의 양을 출력한다.

''' 이 문제는 마지막 포도주잔을 안 먹어도 상관이 없다. 따라서, 경우가 4가지가 나오는데,
    1. 지금 포도주를 안 먹는 경우 --> dp[i-1]    
    1-1. 지금 포도주를 안 먹는 경우이자, 전 포도주도 안 먹는 경우 ?--> dp[i-2] 끝의 두 잔을 비워두는 것은 절대 최대치가 될 수 없으므로 pass 
    2. 지금 포도주를 먹는경우! - 바로 앞 포도주를 먹은 경우 --> 전전 포도주는 먹었을 경우 지금 포도주를 못 마시므로, dp[i-3] + data[i-1] + data[i]
    2-1 지금 포도주를 먹는경우 + 바로앞 포도주 안 마셨고, 전전 포도주는 마시는 경우.--> dp[i-2] + data[i]
    2-2 지금 포도주 마시는 경우 + 바로앞 포도주 안 마셨고, 전전 포도주도 안 마셨고, 3개 전 포도주를 마신 경우 --> dp[i-3] + data[i] ==>결국 2-1에 포함됨 Pass
    2-3 3개전 포도주까지 안마신 경우는 O XXX O인데, 3개의 X중 가운데 포도주는 마셔야 최대치가 될 가능성이 있으므로 이 경우는 Pass 
    
    이렇게 총 3가지 경우만 남는다!! 
    따라서 반복문에 dp[i] = max(위의 3가지 경우들 ) 
    이와 같이 처리해주면 됨.   복잡하게 튜플로 각 dp[i]를 저장할 필요가 없다! '''
n = int(input())
data = [0]
for _ in range(n):
    data.append(int(input()))
if n == 1:
    print(data[1])
    exit()
elif n == 2:
    print(data[1] + data[2])
    exit()
dp = [0]*(n+1)
dp[1] = data[1]
dp[2] = data[1] + data[2]
dp[3] = max( dp[2], data[2] + data[3], dp[1] + data[3] )

for i in range(4,n+1):
    dp[i] = max(dp[i-1], dp[i-3] + data[i-1] + data[i], dp[i-2] + data[i], dp[i-3] + data[i])
print(dp[n])